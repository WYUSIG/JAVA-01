最近在学习八股文，就放点自己写的答案吧~

#### 循环依赖问题

> 答：Spring只能解决scope为singleton，setter依赖注入的循环依赖问题，它是通过了3个Map缓存，提前曝光早期单例Bean来解决，这3个Map在DefaultSingletonBeanRegistry类里面，第一层是singletonObjects，里面存放的是初始化好的Bean对象，第二层是earlySingletonObjects，里面存放的是早期未初始化好的Bean对象，第三层是singletonFactories，value存放的是ObjectFactory。
>
> 举个例子：假设对象A中有属性是对象B，对象B中也有属性是对象A，即A和B循环依赖。
>
> (1).创建对象A，调用A的构造，并把A保存下来。
> (2).然后准备注入对象A中的依赖，发现对象A依赖对象B，那么开始创建对象B。
> (3).调用B的构造，并把B保存下来。
> (4).然后准备注入B的构造，发现B依赖对象A，对象A之前已经创建了，直接获取A并把A注入B（注意此时的对象A还没有完全注入成功，对象A中的对象B还没有注入），于是B创建成功。
> (5).把创建成功的B注入A，于是A也创建成功了。
>
> > 为什么需要第二层Map：主要是为了提高获取早期Bean的效率，因为getObject会执行SmartInstantiationAwareBeanPostProcessor#getEarlyBeanReference来获取早期Bean，做过可以缓存起来
>
> > 为什么Spring解决不了构造器循环依赖：因为构造器注入 Spring 无法使用无参构造器构造出一个Bean对象，也就无法提前曝光一个还没依赖注入的早期Bean对象来终止循环依赖。
>
> > 为什么prototype(原型)的Bean Spring解决不了循环依赖：因为这样会违背原型Bean的定义，原型模式的要求是每次创建新的Bean，不会进行复用

#### hashmap1.7跟1.8？优化点？红黑树化为什么是8？退化为什么？

>答：jdk1.7的HashMap底层数据结构是数组+链表，链表是为了解决哈希冲突问题，如果哈希冲突该位置建立一个链表；而jdk1.8对HashMap进行了一些修改，最大的不同就是引入了红黑树，当链表长度超过8后就会将链表转化成红黑树。
>
>Jdk1.8中链表长度到8 & 数组长度到64时会红黑树化，因为理想情况下使用随机哈希码，容器中节点分布在hash桶中的频率遵循泊松分布，根据泊松分布计算公式计算桶中元素个数与概率的对照表，可以看到元素为8的时候，概率已经非常小，一亿分之6，不到一千万分之一，所以原作者选择了8，是根据概率统计而选择的。
>
>当红黑树内部节点小于等6个的时候会退化，作者选择6而不是7应该使用防止边界条件频繁树化和取消树化的考虑，对于为什么会需要退化，首先TreeNode 相比普通的 Node 来说，会有两倍的空间占用，而且在长度较小的情况下，红黑树的查找效率跟链表差别不大，毕竟HashMap是java提供的基础数据结构，必须在空间和时间上做抉择，选择链表是空间复杂度优先，选择红黑树是时间复杂度优先。

#### 双亲委派模型。JDBC和双亲委派模型关系

>答：双亲委派模型就是当一个类收到了类加载请求，它首先不会尝试自己去加载这个类，而是把这个请求委派给父 类加载器去完成，每一个层次类加载器都是如此，因此所有的加载请求都应该传送到启动类加载器(Bootstrap ClassLoader)中，只有当父类加载器反馈自己无法完成这个请求的时候(在它的加载路径下没有找到所需加载的Class)，子类加载器才会舱室自己去加载。
>
>采用双亲委派模型的一个好处是比如加载位于rt.jar包的类java.lang.Object，不管是哪个加载器加载这个类，最终都是委托给顶层的启动类加载器进行加载，这样就保证了使用不同的类加载器最终得到的都是同一个Object的·Class对象。
>
>JDBC和双亲委派模型关系：
>
>加载数据库驱动类有两种方式：
>
>1：直接Class.forName("com.mysql.jdbc.Driver")，这种没有破坏双亲委派模型。
>
>2：使用java SPI，在META-INF/services/java.sql.Driver文件指明当前的Driver使用哪一个。
>
>当使用Java SPI时就破坏了双亲委派模型，因为ServiceLoader.load代码在DriverManager类里面，这个类在rt.jar包中，因此是启动类加载器来加载你指定的驱动如com.mysql.jdbc.Driver，但是这个驱动类肯定不在%JAVA_HOME%lib下，所以肯定是如法加载mysql的这个类的，那么这个问题是如何解决的呢，按照目前情况来看，这个类只有应用类加载器才能加载，也就是说启动类加载器必须有方法获取应用类加载器，然后通过它去加载，这就是所谓的线程上下文加载器，线程上下文加载器可以通过Thread.setContextClassLoader方法设置，如果不特殊设置会从父类继承，一般是应用程序类加载器。线程上下文类加载器让父类加载器能够通过调用子级类加载器来加载类，这打破双亲委派模型的原则。
>
>>##### 额外知识：
>>
>>启动类/根类加载器（BootStrap ClassLoader）  ——》%JAVA_HOME%lib路径下的jar包
>>
>>拓展类加载器（Extension ClassLoader）            ——》%JAVA_HOME%jre/lib/ext路径下的jar包
>>
>>系统/应用类加载器(Application ClassLoader)       ——》CLASSPATH路径下指定，如未设置则为应用程序当前路径
>>
>>自定义类加载器														——》继承ClassLoader ，实现Class<?> findClass(String name)方法，使用方法：Class.forName("com.sign.Hello", true, new HelloClassLoader());

#### 从ConcurrentHashMap一路问到锁&锁优化->LongAdder->伪共享->缓存行填充->cas等诸多技术细节；

>答：ConcurrentHashMap jdk1.7和jdk1.8区别：1.7是采用了Segment + HashEntry + ReentrantLock的设计，Segment 默认16份，每次操作这一份的数据就会锁住这个Segment
>
>1.8的是采用Node+CAS+synchronized，锁的粒度降低了，而1.8还引入了红黑树，优化长链表查找的时间复杂度
>
>ConcurrentHashMap如何保证线程安全：首先ConcurrentHashMap对很多底层数据结构都加了volatile如数组，Node节点的val和next指针。保证了读的可见性。
>
>初始化方法initTable()：ConcurrentHashMap用了sizeCtl来标记是否有线程在进行初始化工作，这个标志位由volatile修饰，外部是一个循环判断数组是否还未初始化，如果sizeCtl < 0(有线程在初始化)则Thread.yield()放弃cpu时间片，否则使用CAS修改sizeCtl值为-1，再检查一遍数组是否未初始化（双重检查），如果依然未初始化那就开始初始化工作，最后返回数组tab
>
>添加元素方法putVal：先获取低位离散后hash，然后一个无限循环for (Node<K,V>[] tab = table;;)，put完成会break，
>
>判断tab是不是还没初始化，如果是则调用initTable方法，然后进入下次循环(因为是if-else if-else)
>
>判断f = tab[(n - 1) & hash]是不是空，如果是则新建节点使用CAS放入该位置，如果放入成功，跳出循环，否则进入下次循环
>
>判断f.hash是否等于MOVED(-1)，代表正在扩容，如果是则帮忙扩容
>
>否则(else) 对Node节点f进行加锁(synchronized)，然后再次检测f == tab[(n - 1) & hash]，然后判断f.hash是否>0,是则用个binCount记录改位置节点的个数，正常情况遍历到尾节点然后添加新节点到旧的尾节点后面，如果遍历过程中碰到hash和key都相同的讲考虑覆盖
>
>如果f.hash小于0则判断它是不是树，如果是树则按树的方式插入
>
>最后判断binCount是否不等于0，如果>=8则进行树化
>
>最后添加到计数，以及判断扩容等
>
>
>
>锁优化：可以从锁的粒度、性能、重入、公平、自旋锁考虑
>
>LongAdder：AtomicInteger 和 AtomicLong 里的 value 是所有 线程竞争读写的热点数据，将单个 value 拆分成跟线程一样多的数组 Cell[]，每个线程写自己的 Cell[i]++，最后对数组求和。
>
>伪共享：CPU 和主内存之间有好几层缓存，缓存系统中是以缓存行（cache line）为单位存储的，但是如果有多个线程操作不同的成员变量，但是这些遍历存储在相同的缓存行，那么就发生了伪共享，当两个以上CPU都要访问同一个缓存行大小的内存区域时，就会引起冲突，多个个线程就会轮番发送 RFO 消息，占得此缓存行的拥有权。当 core1 取得了拥有权开始更新 X，则 core2 对应的缓存行需要设为 I 状态(失效态)。当 core2 取得了拥有权开始更新 Y，则 core1 对应的缓存行需要设为 I 状态(失效态)。这样cpu就不得不去L3甚至去主存里面取数据，会影响性能
>
>如何避免伪共享：
>
>缓存行填充：如果一条缓存行有 64 字节，而 Java 程序的对象头固定占 8 字节(32位系统)或 12 字节( 64 位系统默认开启压缩, 不开压缩为 16 字节)，所以我们只需要填 6 个无用的长整型补上6*8=48字节，让不同的 VolatileLong 对象处于不同的缓存行，就避免了伪共享( 64 位系统超过缓存行的 64 字节也无所谓，只要保证不同线程不操作同一缓存行就可以)。
>
>使用编译指令，强制使每一个变量对齐：例如可以使数据按64位对齐，那么一个缓存行只有一个可操作对象。
>
>CAS：CAS是一种无锁算法，CAS有3个操作数，内存值V，旧的预期值A，要修改的新值B。当且仅当预期值A和内存值V相同时，将内存值V修改为B，否则什么都不做。而且CAS是CPU指令级的操作，只有一步原子操作。

#### Http请求的完全过程

>1.浏览器根据域名解析ip地址，也就是DNS查找，首先搜索浏览器的DNS缓存，找不到就会搜索操作系统的DNS缓存，系统的DNS缓存找不到就会向路由器发送查询请求，查询路由器缓存，路由器缓存找不到就会去查ISP缓存DNS的服务器。
>
>2.经过TCP 3次握手，浏览器与web服务器建立了一个TCP连接
>
>3.浏览器给web服务器发送一个Http请求
>
>4.服务器端响应Http请求，浏览器得到html代码
>
>5.浏览器解析html代码，并请求html代码中的资源
>
>6.浏览器对页面进行渲染呈现给观众
>
>7.关闭tcp连接